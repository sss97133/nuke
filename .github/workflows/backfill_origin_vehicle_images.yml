name: Backfill Imported Vehicle Images (Origin URLs -> Storage)

on:
  schedule:
    # Fast catch-up: every 15 minutes. GitHub Actions cron is UTC.
    - cron: "*/15 * * * *"
  workflow_dispatch: {}

concurrency:
  group: backfill-origin-vehicle-images
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - name: Backfill origin vehicle images (small batches)
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL || secrets.SUPABASE_PROJECT_URL || secrets.SUPABASEPROJECTURL }}
          # Must be a JWT (legacy anon key), not an sb_publishable_* key.
          SUPABASE_ANON_JWT: ${{ secrets.SUPABASE_ANON_JWT || secrets.SUPABASE_ANON_KEY || secrets.VITE_SUPABASE_ANON_KEY }}
        run: |
          set -euo pipefail

          if [ -z "${SUPABASE_URL:-}" ]; then
            echo "Missing secret SUPABASE_URL"
            exit 2
          fi
          if [ -z "${SUPABASE_ANON_JWT:-}" ]; then
            echo "Missing secret SUPABASE_ANON_JWT"
            exit 2
          fi
          if echo "${SUPABASE_ANON_JWT}" | grep -q '^sb_'; then
            echo "SUPABASE_ANON_JWT must be a legacy JWT (starts with eyJ...), not an sb_* key"
            exit 2
          fi

          post() {
            local path="$1"
            local body="$2"
            curl -sS -w "\nHTTP:%{http_code}\n" "${SUPABASE_URL%/}/functions/v1/${path}" \
              -H "Authorization: Bearer ${SUPABASE_ANON_JWT}" \
              -H "Content-Type: application/json" \
              --data-binary "${body}"
          }

          run_call() {
            local name="$1"
            local path="$2"
            local body="$3"
            echo "$name" >&2
            OUT="$(post "$path" "$body")"
            HTTP="$(echo "$OUT" | tail -n 1 | sed 's/^HTTP://')"
            RESP="$(echo "$OUT" | sed '$d')"
            echo "HTTP $HTTP" >&2
            echo "$RESP" | head -c 1200 >&2
            echo "" >&2
            if [ "$HTTP" -lt 200 ] || [ "$HTTP" -ge 300 ]; then
              echo "Non-2xx response from $path" >&2
              exit 1
            fi
            echo "$RESP" | jq -c . >/dev/null
            echo "$RESP"
          }

          # Fast catch-up, but avoid starvation: process BaT and non-BaT in separate loops.
          # 1) BaT imports (often older than the newest Craigslist batches)
          for i in 1 2 3 4; do
            run_call "backfill-origin-vehicle-images BAT batch $i" "backfill-origin-vehicle-images" \
              '{"batch_size":3,"max_images_per_vehicle":40,"dry_run":false,"include_profile_origins":["bat_import"]}' \
              | jq -c "{kind:\"bat\",i:$i,attempted:.attempted,backfilled:.backfilled,skipped:.skipped,failed:.failed}"
            sleep 2
          done

          # 2) Other imported origins
          for i in 1 2 3 4; do
            run_call "backfill-origin-vehicle-images OTHER batch $i" "backfill-origin-vehicle-images" \
              '{"batch_size":3,"max_images_per_vehicle":35,"dry_run":false,"include_profile_origins":["url_scraper","craigslist_scrape","ksl_import"]}' \
              | jq -c "{kind:\"other\",i:$i,attempted:.attempted,backfilled:.backfilled,skipped:.skipped,failed:.failed}"
            sleep 2
          done


