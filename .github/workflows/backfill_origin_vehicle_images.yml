name: Backfill Imported Vehicle Images (Origin URLs -> Storage)

on:
  schedule:
    # Hourly. GitHub Actions cron is UTC.
    - cron: "15 * * * *"
  workflow_dispatch: {}

concurrency:
  group: backfill-origin-vehicle-images
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    steps:
      - name: Backfill origin vehicle images (small batches)
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL || secrets.SUPABASE_PROJECT_URL || secrets.SUPABASEPROJECTURL }}
          # Must be a JWT (legacy anon key), not an sb_publishable_* key.
          SUPABASE_ANON_JWT: ${{ secrets.SUPABASE_ANON_JWT || secrets.SUPABASE_ANON_KEY || secrets.VITE_SUPABASE_ANON_KEY }}
        run: |
          set -euo pipefail

          if [ -z "${SUPABASE_URL:-}" ]; then
            echo "Missing secret SUPABASE_URL"
            exit 2
          fi
          if [ -z "${SUPABASE_ANON_JWT:-}" ]; then
            echo "Missing secret SUPABASE_ANON_JWT"
            exit 2
          fi
          if echo "${SUPABASE_ANON_JWT}" | grep -q '^sb_'; then
            echo "SUPABASE_ANON_JWT must be a legacy JWT (starts with eyJ...), not an sb_* key"
            exit 2
          fi

          post() {
            local path="$1"
            local body="$2"
            curl -sS -w "\nHTTP:%{http_code}\n" "${SUPABASE_URL%/}/functions/v1/${path}" \
              -H "Authorization: Bearer ${SUPABASE_ANON_JWT}" \
              -H "Content-Type: application/json" \
              --data-binary "${body}"
          }

          run_call() {
            local name="$1"
            local path="$2"
            local body="$3"
            echo "$name"
            OUT="$(post "$path" "$body")"
            HTTP="$(echo "$OUT" | tail -n 1 | sed 's/^HTTP://')"
            RESP="$(echo "$OUT" | sed '$d')"
            echo "HTTP $HTTP"
            echo "$RESP" | head -c 1200
            echo ""
            if [ "$HTTP" -lt 200 ] || [ "$HTTP" -ge 300 ]; then
              echo "Non-2xx response from $path"
              exit 1
            fi
            echo "$RESP" | jq -c . >/dev/null
            echo "$RESP"
          }

          # A few small batches to respect edge runtime limits.
          for i in 1 2 3 4; do
            run_call "backfill-origin-vehicle-images batch $i" "backfill-origin-vehicle-images" \
              '{"batch_size":3,"max_images_per_vehicle":35,"dry_run":false,"include_profile_origins":["url_scraper","bat_import","craigslist_scrape","ksl_import"]}' \
              | jq -c "{i:$i,attempted:.attempted,backfilled:.backfilled,skipped:.skipped,failed:.failed}"
            sleep 2
          done


