name: Environment Variable Monitor

on:
  workflow_dispatch:  # Can be triggered manually
  # Run after the smart repair orchestrator completes
  workflow_run:
    workflows: ["Smart Repair Orchestrator"]
    types:
      - completed
    branches:
      - main
  # Also run when environment-related files change
  push:
    branches:
      - main
    paths:
      - 'src/**/*.tsx'
      - 'src/**/*.ts'
      - '.env*'
      - 'supabase/**'
  schedule:
    - cron: '0 */12 * * *'  # Run every 12 hours

# Permissions needed for creating PRs and issues
permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  analyze-env-variables:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci || npm install

      - name: Create analysis directory
        run: |
          mkdir -p .repair/env-analysis
          
      - name: Identify environment variable usage
        run: |
          # Look for env variable patterns in the codebase
          echo "Analyzing environment variable usage patterns..."
          
          # Find all direct env variable access patterns
          grep -r "process.env" --include="*.ts" --include="*.tsx" --include="*.js" src/ > .repair/env-analysis/node-env.txt || true
          grep -r "import.meta.env" --include="*.ts" --include="*.tsx" --include="*.js" src/ > .repair/env-analysis/vite-env.txt || true
          grep -r "window.__env" --include="*.ts" --include="*.tsx" --include="*.js" src/ > .repair/env-analysis/browser-env.txt || true
          
          # Create a list of all used environment variables
          cat .repair/env-analysis/*.txt | grep -o "process.env\.[A-Z0-9_]*" | sort | uniq | sed 's/process.env\.//g' > .repair/env-analysis/node-vars.txt || true
          cat .repair/env-analysis/*.txt | grep -o "import\.meta\.env\.[A-Z0-9_]*" | sort | uniq | sed 's/import\.meta\.env\.//g' > .repair/env-analysis/vite-vars.txt || true
          cat .repair/env-analysis/*.txt | grep -o "window\.__env\.[A-Z0-9_]*" | sort | uniq | sed 's/window\.__env\.//g' > .repair/env-analysis/browser-vars.txt || true
          
          # Combine all variables into a comprehensive list
          cat .repair/env-analysis/*-vars.txt | sort | uniq > .repair/env-analysis/all-env-vars.txt
          
          echo "Environment variables used in codebase:"
          cat .repair/env-analysis/all-env-vars.txt
          
          # Check for fallback patterns
          if grep -q "getEnv" --include="*.ts" --include="*.tsx" --include="*.js" src/; then
            echo "Fallback system detected with getEnv function"
            FALLBACK_DETECTED=true
          else
            echo "No consistent fallback system detected"
            FALLBACK_DETECTED=false
          fi
          echo "FALLBACK_DETECTED=$FALLBACK_DETECTED" >> $GITHUB_ENV
          
          # Check Supabase variables specifically
          echo "Checking Supabase variables..."
          if grep -q "VITE_SUPABASE_URL\|SUPABASE_URL" .repair/env-analysis/all-env-vars.txt; then
            echo "Supabase URL configuration detected"
            USES_SUPABASE=true
          else
            USES_SUPABASE=false
          fi
          echo "USES_SUPABASE=$USES_SUPABASE" >> $GITHUB_ENV
      
      - name: Check environment file configuration
        run: |
          # Create a report on env file status
          echo "Analyzing environment files..."
          
          # Check for environment files
          if [ -f ".env" ]; then
            echo "Found .env file"
            HAS_ENV=true
          else
            echo "No .env file found"
            HAS_ENV=false
          fi
          echo "HAS_ENV=$HAS_ENV" >> $GITHUB_ENV
          
          if [ -f ".env.production" ]; then
            echo "Found .env.production file"
            HAS_ENV_PROD=true
          else  
            echo "No .env.production file found"
            HAS_ENV_PROD=false
          fi
          echo "HAS_ENV_PROD=$HAS_ENV_PROD" >> $GITHUB_ENV
          
          if [ -f ".env.test" ]; then
            echo "Found .env.test file"
            HAS_ENV_TEST=true
          else
            echo "No .env.test file found"
            HAS_ENV_TEST=false
          fi
          echo "HAS_ENV_TEST=$HAS_ENV_TEST" >> $GITHUB_ENV
          
          # Look for scripts that inject environment variables
          if grep -q "inject-env" package.json; then
            echo "Found environment injection script in package.json"
            HAS_ENV_INJECT=true
          else
            echo "No environment injection script found"
            HAS_ENV_INJECT=false
          fi
          echo "HAS_ENV_INJECT=$HAS_ENV_INJECT" >> $GITHUB_ENV
          
          # Check Vercel configuration
          if [ -f "vercel.json" ]; then
            echo "Found Vercel configuration"
            HAS_VERCEL_CONFIG=true
          else
            echo "No Vercel configuration found"
            HAS_VERCEL_CONFIG=false
          fi
          echo "HAS_VERCEL_CONFIG=$HAS_VERCEL_CONFIG" >> $GITHUB_ENV
      
      - name: Create or update environment helper
        if: env.FALLBACK_DETECTED != 'true' && env.USES_SUPABASE == 'true'
        run: |
          echo "Creating environment helper with three-tier fallback system..."
          
          # Create utils directory if it doesn't exist
          mkdir -p src/utils
          
          # Create environment.ts file with the three-tier fallback
          cat > src/utils/environment.ts << EOF
          /**
           * Three-tier environment variable fallback system
           * 
           * This utility provides a consistent way to access environment variables
           * across different environments with proper fallback mechanisms:
           * 
           * 1. First checks import.meta.env (Vite - development)
           * 2. Then checks process.env (Node - build time)
           * 3. Finally checks window.__env (Browser - runtime, injected during build)
           * 
           * This ensures environment variables are accessible in all contexts.
           */
          
          /**
           * Get an environment variable with three-tier fallback
           * @param key The environment variable key to retrieve
           * @returns The environment variable value or null if not found
           */
          export const getEnv = (key: string): string | null => {
            // Check Vite environment (development)
            if (typeof import !== 'undefined' && 
                import.meta && 
                import.meta.env && 
                import.meta.env[key]) {
              return import.meta.env[key] as string;
            }
            
            // Check Node environment (build time)
            if (typeof process !== 'undefined' && 
                process.env && 
                process.env[key]) {
              return process.env[key] as string;
            }
            
            // Check Browser injected environment (runtime)
            if (typeof window !== 'undefined' && 
                window.__env && 
                window.__env[key]) {
              return window.__env[key] as string;
            }
            
            // Not found in any environment
            return null;
          };
          
          /**
           * Helper to specifically get Supabase credentials consistently
           */
          export const getSupabaseCredentials = () => {
            return {
              supabaseUrl: getEnv('VITE_SUPABASE_URL') || '',
              supabaseAnonKey: getEnv('VITE_SUPABASE_ANON_KEY') || '',
              supabaseServiceKey: getEnv('VITE_SUPABASE_SERVICE_KEY') || ''
            };
          };
          
          // Add TypeScript type definition for window.__env
          declare global {
            interface Window {
              __env: Record<string, string>;
            }
          }
          EOF
          
          echo "Created environment helper with three-tier fallback system"
      
      - name: Create environment variable injection script
        if: env.HAS_ENV_INJECT != 'true' && env.USES_SUPABASE == 'true'
        run: |
          echo "Creating environment variable injection script..."
          
          # Create scripts directory if it doesn't exist
          mkdir -p scripts
          
          # Create inject-env.js for runtime environment variable injection
          cat > scripts/inject-env.js << EOF
          /**
           * Environment Variable Injection Script
           * 
           * This script injects environment variables into the HTML at build time
           * to make them available at runtime in the browser via window.__env
           * 
           * This solves the issue where environment variables are only available
           * at build time in static deployments like Vercel.
           */
          
          const fs = require('fs');
          const path = require('path');
          
          // Get the build output directory (default for Vite is 'dist')
          const buildDir = path.resolve(process.cwd(), 'dist');
          const htmlFile = path.resolve(buildDir, 'index.html');
          
          // Read the HTML file
          let htmlContent = fs.readFileSync(htmlFile, 'utf8');
          
          // Environment variables to inject (must start with VITE_)
          const envVars = {
            VITE_SUPABASE_URL: process.env.VITE_SUPABASE_URL || '',
            VITE_SUPABASE_ANON_KEY: process.env.VITE_SUPABASE_ANON_KEY || '',
            // Only include service key if explicitly provided to this script
            ...(process.env.VITE_SUPABASE_SERVICE_KEY ? 
              { VITE_SUPABASE_SERVICE_KEY: process.env.VITE_SUPABASE_SERVICE_KEY } : {}),
            // Add other environment variables as needed
          };
          
          // Create the script to inject
          const envScript = \`
            <script>
              window.__env = \${JSON.stringify(envVars)};
            </script>
          \`;
          
          // Inject the script right after the <head> tag
          htmlContent = htmlContent.replace('</head>', \`\${envScript}</head>\`);
          
          // Write the modified HTML back to the file
          fs.writeFileSync(htmlFile, htmlContent);
          
          console.log('Injected environment variables into index.html for runtime access');
          EOF
          
          # Update package.json to include the script in the build process
          if [ -f "package.json" ]; then
            # Create backup
            cp package.json package.json.bak
            
            # Check if build:prod script exists
            if grep -q "\"build:prod\":" package.json; then
              # Update existing build:prod script
              sed -i 's/"build:prod": "/"build:prod": "npm run build \&\& node scripts\/inject-env.js \&\& /g' package.json
            else
              # Add new build:prod script
              sed -i '/"build": /a \    "build:prod": "npm run build \&\& node scripts\/inject-env.js",' package.json
            fi
          fi
          
          echo "Created environment variable injection script and updated package.json"
      
      - name: Create or update Vercel configuration
        if: env.HAS_VERCEL_CONFIG != 'true' && env.USES_SUPABASE == 'true'
        run: |
          echo "Creating Vercel configuration..."
          
          # Create vercel.json
          cat > vercel.json << EOF
          {
            "version": 2,
            "builds": [
              {
                "src": "package.json",
                "use": "@vercel/static-build",
                "config": {
                  "buildCommand": "npm run build:prod",
                  "outputDirectory": "dist"
                }
              }
            ],
            "routes": [
              { "handle": "filesystem" },
              { "src": "/(.*)", "dest": "/index.html" }
            ],
            "env": {
              "VITE_DEPLOYMENT_ENV": "production"
            }
          }
          EOF
          
          echo "Created Vercel configuration file"
      
      - name: Create sync-vercel-secrets workflow
        run: |
          echo "Creating Vercel secrets synchronization workflow..."
          
          # Create workflow directory if it doesn't exist
          mkdir -p .github/workflows
          
          # Create workflow file for syncing secrets
          cat > .github/workflows/sync-vercel-secrets.yml << EOF
          name: Sync Vercel Secrets
          
          on:
            workflow_dispatch:  # Can be triggered manually
            push:
              branches:
                - main
              paths:
                - 'vercel.json'
                - '.env.production'
          
          jobs:
            sync-secrets:
              runs-on: ubuntu-latest
              
              steps:
                - name: Checkout repository
                  uses: actions/checkout@v3
                  
                - name: Install Vercel CLI
                  run: npm install -g vercel
                  
                - name: Sync GitHub Secrets to Vercel
                  env:
                    VERCEL_TOKEN: \${{ secrets.VERCEL_TOKEN }}
                    VERCEL_ORG_ID: \${{ secrets.VERCEL_ORG_ID }}
                    VERCEL_PROJECT_ID: \${{ secrets.VERCEL_PROJECT_ID }}
                    VITE_SUPABASE_URL: \${{ secrets.VITE_SUPABASE_URL }}
                    VITE_SUPABASE_ANON_KEY: \${{ secrets.VITE_SUPABASE_ANON_KEY }}
                    VITE_SUPABASE_SERVICE_KEY: \${{ secrets.VITE_SUPABASE_SERVICE_KEY }}
                  run: |
                    # Authenticate with Vercel
                    vercel login --token \$VERCEL_TOKEN
                    
                    # Remove existing environment variables to prevent duplicates
                    echo "Removing existing environment variables..."
                    vercel env rm VITE_SUPABASE_URL production -y --token \$VERCEL_TOKEN || true
                    vercel env rm VITE_SUPABASE_ANON_KEY production -y --token \$VERCEL_TOKEN || true
                    vercel env rm VITE_SUPABASE_SERVICE_KEY production -y --token \$VERCEL_TOKEN || true
                    
                    # Add environment variables from GitHub secrets
                    echo "Adding environment variables to Vercel..."
                    echo \$VITE_SUPABASE_URL | vercel env add VITE_SUPABASE_URL production --token \$VERCEL_TOKEN
                    echo \$VITE_SUPABASE_ANON_KEY | vercel env add VITE_SUPABASE_ANON_KEY production --token \$VERCEL_TOKEN
                    echo \$VITE_SUPABASE_SERVICE_KEY | vercel env add VITE_SUPABASE_SERVICE_KEY production --token \$VERCEL_TOKEN
                    
                    # Trigger a new deployment to apply the changes
                    echo "Triggering new deployment..."
                    vercel --prod --token \$VERCEL_TOKEN
          EOF
          
          echo "Created Vercel secrets synchronization workflow"
      
      - name: Create PR with environment improvements
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure git
          git config --global user.name "Environment Fix Bot"
          git config --global user.email "env-bot@example.com"
          
          # Create a branch for the fixes
          BRANCH_NAME="auto-fix/env-variables-$(date +%Y%m%d%H%M%S)"
          git checkout -b $BRANCH_NAME
          
          # Add changes
          git add .
          
          # Prepare PR title and message based on what we created
          TITLE="🔧 Environment Configuration: Improved Three-Tier Fallback System"
          BODY="This PR implements or enhances the three-tier environment variable fallback system required for reliable static deployments.

          ## Changes Made:
          "
          
          if [ "$FALLBACK_DETECTED" = "false" ]; then
            BODY="${BODY}
          - ✅ Added environment.ts helper with three-tier fallback system
          "
          fi
          
          if [ "$HAS_ENV_INJECT" = "false" ]; then
            BODY="${BODY}
          - ✅ Added inject-env.js script for runtime environment variables
          - ✅ Updated package.json build:prod script to inject variables
          "
          fi
          
          if [ "$HAS_VERCEL_CONFIG" = "false" ]; then
            BODY="${BODY}
          - ✅ Created Vercel configuration file for static deployments
          "
          fi
          
          BODY="${BODY}
          - ✅ Added sync-vercel-secrets workflow to synchronize environment variables
          
          This implementation ensures environment variables are consistently accessible across:
          1. Development (import.meta.env)
          2. Build time (process.env)
          3. Runtime in browser (window.__env)
          
          For Supabase integration, the credentials will be properly available in all environments."
          
          # Commit changes
          git commit -m "$TITLE" -m "$BODY"
          
          # Push branch
          git push origin $BRANCH_NAME
          
          # Create PR
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{
              \"title\": \"$TITLE\",
              \"body\": \"$BODY\",
              \"head\": \"$BRANCH_NAME\",
              \"base\": \"main\"
            }"
